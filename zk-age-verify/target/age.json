{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":14391311827510199444,"abi":{"parameters":[{"name":"age_commit","type":{"kind":"field"},"visibility":"public"},{"name":"age","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"expected_age","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"age_blinding","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"}}},"bytecode":"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","debug_symbols":"5Z3biiIxFEX/pZ59yLmkkvgrw9B4bQRR8TIwiP8+1Y2RBsXGqSg5u98sK+ewNmplWbHKYzOdjQ/vb4vVfL1rhr+OzXI9Ge0X61W3dWzk86ndZrT62NrtR9t9M1THg2a2mnaPKJ0GzXyxnDVDbk+Dq6Hs6DyUlS5DWz79HjT6xN7+ib3bJ/YOt3qLb3Nvdt/05uByc47u/0FiLSCpFhBy1ZBQX5I2XUiCk/uDiUJ+axMl3wObbWKLTWy1ie1fii2UMrZIvD84UcZO0ufT28InDPAJI3zChJ6QHXxCqjdhmyFS6KHLzPAJBf5dqvAJ4Z2G4Z2G4Z2G4Z2G4Z1G4J1GKnaaQgkrdppCCeGdRhQ+IbzTCLzTCLzTCLzTCLzTKLzTKLzTKLzTKLzTqMInhHcahXcahXcahXcahXcaD+80Ht5pPLzTeHin8QqfEN5pPLzT+HqdhhxnCnKhx+++fL1WUy5jvV5TLGNbr9mUy/hat1EXMra62AObbWKLTWy1ie1tYr9WArzkweR96IEdbGJHm9jJJHZwNrHJJjbbxBab2GoT29vEtjlLBpuzZHjxLBkuX4V86nMJajKJHZ1NbLKJzTaxxSa22sT2NrFbm9jBJrbNWTLanCWTzVky9Z4lw+XcLwf9ZjCFKBk7Or4/uNAaT2L4hAKfUOET+noTaj7U9LreNrXwCQN8wgifMKEnJOfQD6bk4K2mW3LHjwjvNeQUP2LFZlMqYsVqUypixW5TKmLFclMqYsV2Uygi4dsN4dsNVWw3hTScKrabUhEVPyK+3RC+3RC+3RC+3RC+3TC+3TC+3TD+uRvGP3fT//aa9UfEtxvGtxuGX5cihl+YIsZfmZJ67abYJY4k9fpNwZD1Gk7BkPU6TsGQ+hNC3vYcF88lonJV0j5eEh4viY+X3JwnlDW/YNclt28EeL+EHi+5eUzwmrP4cF0ij5V0G+PtYrlcvL99/bO17uk/o+1iNF7Ozpvzw2ryZe/+7ybvyfWb7Xoymx62s49On/u69v8A","file_map":{"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"62":{"source":"use std::hash::poseidon2::Poseidon2;\n\nfn main(age_commit: pub Field, age: u8, expected_age: pub u8, age_blinding: u32) -> pub bool {\n    let age_field = [age as Field];\n    let recomputed_age_commit = Poseidon2::hash(age_field, age_blinding);\n\n    // Ensure the commitments are valid\n    let commit_valid = (recomputed_age_commit == age_commit);\n\n    // Perform the comparison on the actual age values\n    let comparison = (age >= expected_age);\n\n    // The final assertion combines the validity of commitments and the comparison result\n    assert(commit_valid & comparison);\n    commit_valid & comparison\n}\n\n#[test]\nfn test_verify_age_this() {\n    let age: u8 = 20;\n    let expected_age: u8 = 18;\n\n    let age_blinding = 1;\n\n    let age_commit = 0x29a0e60256827455d5daf3bd6bae941ecc9d216992e04e044d01f0f00fbf9851;\n\n    let result = main(age_commit, age, expected_age, age_blinding);\n\n    assert(result); // Should be true since 20 >= 18\n}\n\n#[test]\nfn test_verify_age() {\n    let age: u8 = 20;\n    let expected_age: u8 = 18;\n    let age_field = [age as Field];\n\n    let age_blinding = 1;\n\n    let age_commit = Poseidon2::hash(age_field, age_blinding);\n\n    let result = main(age_commit, age, expected_age, age_blinding);\n\n    assert(result); // Should be true since 20 >= 18\n}\n\n#[test]\nfn test_verify_age_fail() {\n    let age: u8 = 17;\n    let expected_age: u8 = 18;\n    let age_field = [age as Field];\n\n    let age_blinding = 1;\n\n    let age_commit = Poseidon2::hash(age_field, age_blinding);\n\n    let result = main(age_commit, age, expected_age, age_blinding);\n\n    assert(!result); // Should be false since 17 < 18\n}\n\n#[test]\nfn test_verify_age_fail_wrong_age_commit() {\n    let age: u8 = 30;\n    let expected_age: u8 = 18;\n    let age_field = [age as Field];\n    let age_blinding = 3;\n\n    let age_commit = std::hash::pedersen_hash_with_separator(age_field, age_blinding);\n\n    let result = main(age_commit, age, expected_age, age_blinding);\n\n    assert(!result);\n}\n","path":"/Users/christian.leovido/workspace/zk-explorations/zk-age-verify/src/main.nr"}},"names":["main"],"brillig_names":["directive_invert","directive_integer_quotient"]}